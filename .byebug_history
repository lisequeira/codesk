c
@unavailable_dates.flatten
@unavailable_dates
@unavailable_date
n
exit
n
exit
n
exit
n
@unavailable_dates
      (l.start_date.to_date..l.end_date.to_date).map(&:to_s)
      return [] if l.start_date.nil? || l.end_date.nil?
@@unavailable_dates = @space.listings.map do |l|
      (l.start_date.to_date..l.end_date.to_date).map(&:to_s)
      return [] if l.start_date.nil? || l.end_date.nil?
@@unavailable_dates = @space.listings.map do |l|
n
    end.flatten
      (l.start_date.to_date..l.end_date.to_date).map(&:to_s)
      return [] if l.start_date.nil? || l.end_date.nil?
@unavailable_dates = @space.listings.map do |l|
continue
@listing
listing_params
continue
listing_params["start_date"].to_datetime
listing_params["start_date"]
listing_params
@listing
next
@listing
listing_params
params
continue
params
listing_params
@listing
continue
listing_params
@listing
quit
exit
continue
auth.info
auth
continue
auth.info
user
quit
auth.info
user
continue
auth.info
user
continue
user
continue
auth.info
user
exit
auth.info
user
quit
auth.info
user
continue
auth.info
user
quit
auth.info.email
auth.info
user
continue
auth.info
 User.where(provider: auth.provider, uid: auth.uid).first
user
quit
auth.info
user_params
exit
auth.info.email
auth.info
auth.provider
auth.email
auth
User.where(provider: auth.provider, uid: auth.uid).first
user
user.update(user_params)
user.save
user_params
User.where(email: auth.info.email).first
User.where(provider: auth.provider, uid: auth.uid).first
user
exit
user.errors.messages
user.persisted?
user
